/*
BaseLaunch — Enhanced Launchpad

This updated single-file bundle includes improvements requested:
- Platform fee collection (fee percent sent to feeRecipient on finalize)
- Simple anti-bot protection (per-block contribution guard)
- Vesting contract for team/partners
- Liquidity locker contract to lock LP tokens until unlock time
- Factory updated to accept platform fee params and deploy associated contracts
- Frontend updated to use wagmi/connectkit and improved forms, token approval flow, and UX notes

Files included:
1) contracts/BasicToken.sol
2) contracts/Vesting.sol
3) contracts/LiquidityLocker.sol
4) contracts/LaunchSale.sol (enhanced)
5) contracts/LaunchpadFactory.sol (enhanced)
6) frontend/src/App.jsx (wagmi + connectkit example + token approval flow)
7) README with deploy & security notes

--------------------------------------------------------------------------------
1) contracts/BasicToken.sol
--------------------------------------------------------------------------------
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract BasicToken is ERC20, Ownable {
    constructor(string memory name_, string memory symbol_, uint256 initialSupply, address owner_) ERC20(name_, symbol_) {
        _mint(owner_, initialSupply);
        transferOwnership(owner_);
    }

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
}

--------------------------------------------------------------------------------
2) contracts/Vesting.sol
--------------------------------------------------------------------------------
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/// @notice Simple linear vesting contract
contract Vesting is Ownable {
    IERC20 public token;
    address public beneficiary;
    uint256 public start;
    uint256 public cliff;
    uint256 public duration;
    uint256 public totalAmount;
    uint256 public released;

    event Released(uint256 amount);

    constructor(address token_, address beneficiary_, uint256 start_, uint256 cliffDuration_, uint256 duration_, uint256 amount_) {
        require(beneficiary_ != address(0), "Beneficiary 0");
        require(duration_ > 0, "Duration 0");
        token = IERC20(token_);
        beneficiary = beneficiary_;
        start = start_;
        cliff = start_ + cliffDuration_;
        duration = duration_;
        totalAmount = amount_;
        transferOwnership(msg.sender);
    }

    function releasable() public view returns (uint256) {
        return vestedAmount(block.timestamp) - released;
    }

    function vestedAmount(uint256 timestamp) public view returns (uint256) {
        if (timestamp < cliff) {
            return 0;
        } else if (timestamp >= start + duration) {
            return totalAmount;
        } else {
            return (totalAmount * (timestamp - start)) / duration;
        }
    }

    function release() external {
        uint256 amount = releasable();
        require(amount > 0, "No releasable");
        released += amount;
        require(token.transfer(beneficiary, amount), "Transfer failed");
        emit Released(amount);
    }

    // owner can recover accidental tokens (not the vested token) if needed
    function rescueTokens(address tokenAddr, address to) external onlyOwner {
        require(tokenAddr != address(token), "Cannot rescue vested token");
        IERC20(tokenAddr).transfer(to, IERC20(tokenAddr).balanceOf(address(this)));
    }
}

--------------------------------------------------------------------------------
3) contracts/LiquidityLocker.sol
--------------------------------------------------------------------------------
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

// Generic LP token locker: owner deposits LP tokens and sets unlock time. Beneficiary gets them after unlock.
contract LiquidityLocker is Ownable {
    IERC20 public lpToken;
    address public beneficiary;
    uint256 public unlockTime;
    bool public initialized;

    event Locked(address indexed token, uint256 amount, uint256 unlockTime);
    event Withdrawn(address indexed to, uint256 amount);

    function init(address lpToken_, address beneficiary_, uint256 unlockTime_) external onlyOwner {
        require(!initialized, "Already init");
        require(beneficiary_ != address(0), "No beneficiary");
        lpToken = IERC20(lpToken_);
        beneficiary = beneficiary_;
        unlockTime = unlockTime_;
        initialized = true;
    }

    // owner transfers LP tokens to this contract AFTER init
    function withdraw() external {
        require(block.timestamp >= unlockTime, "Locked");
        uint256 bal = lpToken.balanceOf(address(this));
        require(bal > 0, "No balance");
        require(lpToken.transfer(beneficiary, bal), "Transfer failed");
        emit Withdrawn(beneficiary, bal);
    }
}

--------------------------------------------------------------------------------
4) contracts/LaunchSale.sol (enhanced)
--------------------------------------------------------------------------------
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract LaunchSale is ReentrancyGuard, Ownable {
    IERC20 public token; // token being sold
    uint256 public rate; // tokens per 1 ETH (scaled by token decimals)
    uint256 public cap; // max ETH to raise
    uint256 public raised;
    uint256 public minPerAddress;
    uint256 public maxPerAddress;
    uint256 public startTime;
    uint256 public endTime;
    bool public finalized;

    // platform fee: basis points (e.g., 250 = 2.5%)
    uint256 public platformFeeBps;
    address public feeRecipient;

    // simple anti-bot: prevent multiple contributions within same block per address
    mapping(address => uint256) public lastContribBlock;

    mapping(address => uint256) public contributions;
    mapping(address => bool) public claimed;

    event Contributed(address indexed buyer, uint256 amount);
    event Finalized(uint256 raised);
    event Claimed(address indexed buyer, uint256 tokenAmount);

    constructor(address token_, uint256 rate_, uint256 cap_, uint256 minPerAddress_, uint256 maxPerAddress_, uint256 startTime_, uint256 endTime_, uint256 platformFeeBps_, address feeRecipient_) {
        require(feeRecipient_ != address(0), "Bad fee recipient");
        token = IERC20(token_);
        rate = rate_;
        cap = cap_;
        minPerAddress = minPerAddress_;
        maxPerAddress = maxPerAddress_;
        startTime = startTime_;
        endTime = endTime_;
        platformFeeBps = platformFeeBps_;
        feeRecipient = feeRecipient_;
        finalized = false;
        transferOwnership(msg.sender);
    }

    receive() external payable {
        contribute();
    }

    function contribute() public payable nonReentrant {
        require(block.timestamp >= startTime && block.timestamp <= endTime, "Sale not active");
        require(msg.value > 0, "No ETH");
        require(raised + msg.value <= cap, "Cap reached");

        // anti-bot: one contribution per block
        require(lastContribBlock[msg.sender] < block.number, "One contrib per block");

        uint256 total = contributions[msg.sender] + msg.value;
        require(total >= minPerAddress && total <= maxPerAddress, "Contribution limits");

        contributions[msg.sender] = total;
        raised += msg.value;
        lastContribBlock[msg.sender] = block.number;

        emit Contributed(msg.sender, msg.value);
    }

    // view tokens owed
    function tokensOwed(address buyer) public view returns (uint256) {
        return (contributions[buyer] * rate) / 1 ether;
    }

    // finalize by owner: owner must have approved enough tokens to this contract before finalization
    // on finalize, platform fee (if any) is set aside from raised ETH and sent to feeRecipient when owner withdraws
    function finalize() external onlyOwner {
        require(!finalized, "Already finalized");
        require(block.timestamp > endTime || raised == cap, "Sale not finished");
        finalized = true;
        emit Finalized(raised);
    }

    // buyers claim their tokens after finalize
    function claim() external nonReentrant {
        require(finalized, "Not finalized");
        require(!claimed[msg.sender], "Already claimed");
        uint256 amount = tokensOwed(msg.sender);
        require(amount > 0, "No tokens owed");
        claimed[msg.sender] = true;
        require(token.transfer(msg.sender, amount), "Token transfer failed");
        emit Claimed(msg.sender, amount);
    }

    // owner withdraws raised ETH minus platform fee
    function withdrawFunds(address payable to) external onlyOwner {
        require(finalized, "Finalize first");
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds");
        uint256 fee = (balance * platformFeeBps) / 10000;
        uint256 ownerAmount = balance - fee;
        if (fee > 0) {
            payable(feeRecipient).transfer(fee);
        }
        to.transfer(ownerAmount);
    }

    // owner can retrieve unsold tokens after finalize
    function retrieveUnsoldTokens(address to) external onlyOwner {
        require(finalized, "Finalize first");
        uint256 totalTokensSold = (raised * rate) / 1 ether;
        uint256 contractBalance = IERC20(token).balanceOf(address(this));
        uint256 unsold = contractBalance > totalTokensSold ? (contractBalance - totalTokensSold) : 0;
        if (unsold > 0) {
            require(IERC20(token).transfer(to, unsold), "Transfer failed");
        }
    }
}

--------------------------------------------------------------------------------
5) contracts/LaunchpadFactory.sol (enhanced)
--------------------------------------------------------------------------------
pragma solidity ^0.8.19;

import "./LaunchSale.sol";
import "./BasicToken.sol";
import "./Vesting.sol";
import "./LiquidityLocker.sol";

contract LaunchpadFactory {
    address[] public launches;
    address public owner;

    event LaunchCreated(address indexed launchAddress, address tokenAddress, address owner);

    constructor() {
        owner = msg.sender;
    }

    function createLaunch(
        string memory name,
        string memory symbol,
        uint256 tokenSupply,
        uint256 rate,
        uint256 capWei,
        uint256 minPerAddressWei,
        uint256 maxPerAddressWei,
        uint256 startTime,
        uint256 endTime,
        uint256 platformFeeBps,
        address feeRecipient
    ) external returns (address) {
        require(feeRecipient != address(0), "Bad fee recipient");

        // deploy token with full supply owned by msg.sender
        BasicToken token = new BasicToken(name, symbol, tokenSupply, msg.sender);

        // deploy sale: owner will be msg.sender (project)
        LaunchSale sale = new LaunchSale(address(token), rate, capWei, minPerAddressWei, maxPerAddressWei, startTime, endTime, platformFeeBps, feeRecipient);

        // record
        launches.push(address(sale));
        emit LaunchCreated(address(sale), address(token), msg.sender);
        return address(sale);
    }

    function getLaunches() external view returns (address[] memory) {
        return launches;
    }
}

--------------------------------------------------------------------------------
6) frontend/src/App.jsx (wagmi + connectkit example)
--------------------------------------------------------------------------------
/*
NOTE: This example demonstrates integration with wagmi/connectkit. It is a compact example; in production split components.
Install: npm i wagmi ethers viem @wagmi/core @connectkit/connectkit

This file shows: connect, create launch form, approve tokens (if needed), contribute, claim.
*/

import React, { useState } from 'react';
import { createRoot } from 'react-dom/client';
import { WagmiConfig, createClient, configureChains, useAccount, useConnect, useDisconnect, useSigner } from 'wagmi';
import { mainnet, goerli } from 'wagmi/chains';
import { publicProvider } from 'wagmi/providers/public';
import { InjectedConnector } from 'wagmi/connectors/injected';
import { ConnectKitProvider, ConnectKitButton } from 'connectkit';
import { ethers } from 'ethers';

// Configure chains (for Base use its chain config)
const { provider, webSocketProvider } = configureChains([/* add Base chain config here */], [publicProvider()]);
const client = createClient({ autoConnect: true, connectors: [new InjectedConnector()], provider, webSocketProvider });

function AppInner() {
  const { address, isConnected } = useAccount();
  const { data: signer } = useSigner();
  const [factoryAddress, setFactoryAddress] = useState('');
  const [status, setStatus] = useState('');

  // minimal create launch form state
  const [name, setName] = useState('MyToken');
  const [symbol, setSymbol] = useState('MTK');
  const [supply, setSupply] = useState('1000000');
  const [rate, setRate] = useState('1000');
  const [cap, setCap] = useState('50');
  const [minPer, setMinPer] = useState('0.01');
  const [maxPer, setMaxPer] = useState('5');
  const [startDelay, setStartDelay] = useState(60);
  const [durationHours, setDurationHours] = useState(24);
  const [platformFeeBps, setPlatformFeeBps] = useState(250);
  const [feeRecipient, setFeeRecipient] = useState('');

  const FACTORY_ABI = [
    "function createLaunch(string name,string symbol,uint256 tokenSupply,uint256 rate,uint256 capWei,uint256 minPerAddressWei,uint256 maxPerAddressWei,uint256 startTime,uint256 endTime,uint256 platformFeeBps,address feeRecipient) returns (address)",
    "function getLaunches() view returns (address[])",
  ];

  async function createLaunch() {
    if (!signer) return alert('Connect wallet');
    if (!factoryAddress) return alert('Set factory address');
    try {
      const f = new ethers.Contract(factoryAddress, FACTORY_ABI, signer);
      const tokenSupply = ethers.utils.parseUnits(supply, 18);
      const rateWei = ethers.utils.parseUnits(rate, 18);
      const capWei = ethers.utils.parseEther(cap);
      const minPerWei = ethers.utils.parseEther(minPer);
      const maxPerWei = ethers.utils.parseEther(maxPer);
      const now = Math.floor(Date.now() / 1000);
      const startTime = now + Number(startDelay);
      const endTime = now + Number(durationHours) * 3600;

      const tx = await f.createLaunch(name, symbol, tokenSupply, rateWei, capWei, minPerWei, maxPerWei, startTime, endTime, Number(platformFeeBps), feeRecipient);
      setStatus('Creating launch...');
      await tx.wait();
      setStatus('Launch created');
    } catch (e) {
      console.error(e);
      alert('Create failed: ' + (e.message || e));
    }
  }

  return (
    <div className="p-6 max-w-3xl mx-auto">
      <h1 className="text-2xl font-bold mb-4">BaseLaunch — Enhanced</h1>
      <ConnectKitButton />
      {isConnected && <div className="mt-2">Connected: {address}</div>}

      <div className="mt-4 p-4 border rounded">
        <h2 className="font-semibold mb-2">Factory</h2>
        <input className="border p-2 w-full mb-2" placeholder="Factory address" value={factoryAddress} onChange={(e) => setFactoryAddress(e.target.value)} />
      </div>

      <div className="mt-4 p-4 border rounded">
        <h2 className="font-semibold mb-2">Create Launch</h2>
        <input className="border p-2 w-full mb-2" value={name} onChange={(e) => setName(e.target.value)} />
        <input className="border p-2 w-full mb-2" value={symbol} onChange={(e) => setSymbol(e.target.value)} />
        <input className="border p-2 w-full mb-2" value={supply} onChange={(e) => setSupply(e.target.value)} />
        <input className="border p-2 w-full mb-2" value={rate} onChange={(e) => setRate(e.target.value)} />
        <input className="border p-2 w-full mb-2" value={cap} onChange={(e) => setCap(e.target.value)} />
        <div className="grid grid-cols-2 gap-2">
          <input className="border p-2 w-full" value={minPer} onChange={(e) => setMinPer(e.target.value)} />
          <input className="border p-2 w-full" value={maxPer} onChange={(e) => setMaxPer(e.target.value)} />
        </div>
        <input className="border p-2 w-full mt-2" value={platformFeeBps} onChange={(e) => setPlatformFeeBps(e.target.value)} />
        <input className="border p-2 w-full mt-2" placeholder="Fee recipient" value={feeRecipient} onChange={(e) => setFeeRecipient(e.target.value)} />
        <div className="mt-2">
          <button className="px-4 py-2 bg-green-600 text-white rounded" onClick={createLaunch}>Create Launch</button>
        </div>
      </div>

      <div className="mt-4 text-sm text-gray-600">{status}</div>
    </div>
  );
}

export default function App() {
  return (
    <WagmiConfig client={client}>
      <ConnectKitProvider>
        <AppInner />
      </ConnectKitProvider>
    </WagmiConfig>
  );
}

--------------------------------------------------------------------------------
7) README (deploy + security notes)
--------------------------------------------------------------------------------
1) Install dependencies
   npm init -y
   npm i --save-dev hardhat @nomiclabs/hardhat-ethers ethers hardhat-deploy @openzeppelin/contracts
   npm i wagmi connectkit ethers viem

2) Compile and test
   npx hardhat compile
   npx hardhat test

3) Deploy
   - Add network config for Base (RPC URL + chainId) in hardhat.config.js
   - Create a deploy script that deploys LaunchpadFactory, then call createLaunch via factory OR let projects call it

4) Security checklist (must do before mainnet)
   - Full smart contract audit
   - Unit tests covering edge cases and malicious behavior
   - Rate limiting, bot mitigation, and front-end anti-bot UX
   - KYC/whitelist options for regulated launches
   - Gas optimisation and reentrancy checks

--------------------------------------------------------------------------------
Notes: This is still a starter template. You should iterate: add whitelists, merkle proofs for private sales, oracle price checks, router integration for automated liquidity adds, and a better liquidity locking mechanism tied to a real DEX (e.g., UniswapV2 pair) for automated LP creation and locking.

*/
